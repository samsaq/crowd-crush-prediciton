/* Crowd Simulator Engine
** Copyright (C) 2018 - Inria Rennes - Rainbow - Julien Pettre
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
**
** Authors: Tristan Le Bouffant, Julian Joseph
**
** Contact: crowd_group@inria.fr
*/

//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.18444
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace devUnity
{
	public class TrigoTools
	{
		/** Math methods **/
		static public float getPi()
		{
			return Mathf.PI;
		}
			
		static public float getPiInDegree()
		{
			return RadianToDegree(Mathf.PI);
		}
			
		static public float RadianToDegree(float radian)
		{
			return 180.0f * radian / getPi(); 
		}
			
		static public float DegreeToRadian(float degree)
		{
			return getPi() * degree / 180.0f; 
		}
			
		static public float getAngleInTrigoRad(float angle)
		{
			float returnVal = angle;

			// si trop proche de 0 : approximation des doubles
			returnVal = (Mathf.Sqrt(returnVal*returnVal)<0.0001) ? 0.0f : returnVal; // € [0,2pi]

			// si >2pi ou <-2pi
			while (returnVal>2*getPi())
			{
				returnVal -= 2*getPi();
			}
			while (returnVal<-2*getPi())
			{
				returnVal += 2*getPi();
			}		
			if(returnVal<0)
				returnVal = 2*getPi()+returnVal;
			return returnVal;
		}
	}
}

